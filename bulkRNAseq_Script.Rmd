
---
title: "bulkRNAseq Analysis Demo Dataset"
author: "Moritz Madern"
output:
  html_document:
    toc: yes
    df_print: paged
  pdf_document:
    toc: yes
---
<br><br><br>


```{r Load required packages, echo = FALSE, message = FALSE, warning = FALSE, include=FALSE}

library(DESeq2)
library(tidyverse)
library(RColorBrewer)
library(dendextend)
library(gprofiler2)
library(rlist)
library(plotly)
library(reshape2)
library(gplots)

```
<br><br><br>   
  
# Chosen Parameters 

This section allows the user to set parameters that are specific to the dataset to be analysed (e.g., file path to count matrix, group specifications, desired pairwise group comparisons, etc.). This is the only section of the script that requires active user input. If the script produces errors down the line, it is most likely due to incorrect parameter specifications!

```{r Define parameters, message = FALSE, warning = FALSE}

## specify working directory
wd = getwd()

## specify file path to data input (tab-separated count matrix + some extra columns denoting gene ids and gene names etc.)
filepath = "./DemoDataset_countMatrix.tsv"

## specify unique gene id column name
unique_id = "gene_id"

## specify gene name column
gene_name = "gene_name"

## specify count column regular expression pattern
count_column_pattern = "_S[0-9]*$"

## specify group names
groups = rep(c("KO_effector","WT_naive", "WT_effector", "KO_naive"), each=3)

## specify sample names in the order they are written in the count table
samplenames = c("KO_effector_10", "KO_effector_11", "KO_effector_12", 
                "WT_naive_1", "WT_naive_2", "WT_naive_3", 
                "WT_effector_4", "WT_effector_5", "WT_effector_6", 
                "KO_naive_7", "KO_naive_8", "KO_naive_9")

## specify batches as factor (if present. Else: set to NULL)
batch = NULL
  
## specify reordering indices as numerical vector for clustering sample visualization (if wanted. Else: set to NULL)
reorder = c(4,5,6,10,11,12,7,8,9,1,2,3)

## specify minimum number read counts per gene across all samples. Genes with total count below the threshold will be filtered out.
min_counts_threshold = 50

## define number of k-means clusters
k_clusters = 7

## specify if log2 counts should be standardized within each gene for the clustering (If FALSE, they will only centered)
standardize_before_clustering = TRUE

## specify if genes should be additionally filtered for overall significance (H0: no difference between groups) before clustering. Recommended if standardize_before_clustering = TRUE
ANOVA_filter_before_clustering = TRUE

## specify at which p-value cutoff the ANOVA_filter_for_clustering should be applied
adj.pval_cutoff = 0.05

## specify if enrichment analysis (ORA, using gProfiler) on k-means clusters should be performed
enrichment_analysis = TRUE

## specify if enrichment analysis (ORA, using gProfiler) should be performed against a custom background (i.e. all the genes quantified in the experiment). Else, enrichment is tested against the whole annotated genome of the specified organism. Note that this can produce different results!
custom_background = TRUE

## define organism for enrichment analysis (note: "mmusculus" for mouse, "hsapiens" for human, etc)
organism = "mmusculus"

## define adj. pval-threshold for enrichment testing via g:Profiler
pval_threshold_enrichment = 0.05

## define the database sources from which annotated gene sets are tested for enrichment
sources_enrichment = c("GO", "KEGG", "REAC", "WP", "CORUM")

## specifiy the column that indicates whether a geine is protein coding or not
biotype_colname <- "gene_biotype"

## specify the name that, in the above column, indicates a protein coding gene. Only protein-coding genes will be taken into account for enrichment testing
proteincoding_entry <- "protein_coding"

## pairwise comparison
pairwise_comp = list(c("KO_naive", "WT_naive"),c("WT_effector","WT_naive"))

## genes of special interest
genes_of_special_interest = c("Il2", "Il4", "Bcl6", "Gata3", "Rin1", "Rin3", "Rin2", "Cxcr5", "Ifng", "Stat4", "Eif5b", "Foxo1", "Sox12", "Ncor2","Jun")

## specify whether output matrix should be exported as txt-file
export_matrix = TRUE

```


```{r Source functions etc, echo = FALSE, message = FALSE, warning = FALSE}

## source functions
source(file="functions.R")


## create required folders
if (!"clusters" %in% list.files()){
  dir.create("clusters")
}
if (!"enrichment" %in% list.files()){
  dir.create("enrichment")
}    
if (!"figures" %in% list.files()){
  dir.create("figures")
}    

```
<br><br><br>   













# Overview and Filtering

```{r Read in data and extract count matrix, echo = FALSE, message = FALSE, warning = FALSE}

## read in count table
df <- read.delim(file=filepath, sep="\t", header=TRUE)


## rename gene name column to "gene_name"
names(df)[names(df) == gene_name] <- "gene_name"


## rename unique id column to "gene_id"
names(df)[names(df) == unique_id] <- "gene_id"


## extract count data as matrix, add unique variable as rownames to count matrix, change column names to samplenames
bool_count_columns <- grepl(names(df), pattern=count_column_pattern)
m_counts <- as.matrix(df[,bool_count_columns])
writeLines("Overview of samples:")
if (is.null(batch)){
  data.frame(column_names = colnames(m_counts), samplenames=samplenames, groups=groups)
} else {
  data.frame(column_names = colnames(m_counts), samplenames=samplenames, groups=groups, batch=batch)
}
rownames(m_counts) <- df$gene_id
colnames(m_counts) <- samplenames


## filter out rows (genes) with only NAs (or 0 counts)
m_counts[is.na(m_counts)] <- 0
m_bool <- m_counts == 0
bool_kick <- apply(m_bool, FUN=all, MARGIN = 1)
df <- df[!bool_kick,]
m_counts <- m_counts[!bool_kick,]


## filter out rows (genes) that do not pass the minimum counts threshold:
writeLines(paste0("number of genes before filtering for at least ", min_counts_threshold, " counts per gene across all samples: ", nrow(m_counts)))
bool_keep <- rowSums(m_counts, na.rm=TRUE) > min_counts_threshold
df <- df[bool_keep,]
m_counts <- m_counts[bool_keep,]
writeLines(paste0("number of genes after filtering for at least ", min_counts_threshold, " counts per gene across all samples: ", nrow(m_counts)))

```


```{r Define some relevant variables, echo = FALSE, message = FALSE, warning = FALSE}

## relevant variables
k <- ncol(m_counts)  ## number of samples
m <- length(unique(groups))  ## number of groups
colors_groups <- setNames(brewer.pal(m, "Pastel1"), nm=unique(groups))
bool_kick <- is.na(names(colors_groups))
colors_groups <- colors_groups[!bool_kick]


## give a unique color to each gene
f_genes <- colorRampPalette(c("darkslateblue","blue","red","darkorchid","aquamarine","lightgreen","navy","turquoise","forestgreen","skyblue","plum","dodgerblue2","darkseagreen2", "cadetblue4", "chocolate", "bisque", "gold", "deeppink", "dodgerblue4", "indianred4", "indianred1", "lightsalmon1", "midnightblue", "mediumblue", "orange1", "mediumpurple3", "red3", "rosybrown2", "turquoise2", "wheat2", "slateblue2", "royalblue2", "purple2", "deeppink4", "firebrick", "coral", "tomato2", "#ff073a", "#06ffcb", "#00725a", "#610043", "#0024c3","#c30024", "#e94b3c", "#e94b3c", "#9becf3", "#9af3cd", "#cc9af2", "#d9a583", "#F0C013"))
col_genes <- sample(f_genes(length(df$gene_id)))
names(col_genes) <- df$gene_id
df$col_genes <- col_genes


## extract gene id of genes of interest
gene_id_genesOfInterest <- df$gene_id[df$gene_name %in% genes_of_special_interest]


## define enrichment_filepath
enrichment_filepath <- paste0(wd, "/enrichment")

```

<br><br><br><br>   












# Data Normalization

Data normalization is performed using DESeq's estimateSizeFactors function which estimates sample-wise scaling factors. First the unnormalized input data is visualized:

```{r Unnormalized counts, echo = FALSE, message = FALSE, warning = FALSE, fig.align="center"}

## writeLines for html output
writeLines("plotting barplot and boxplots for unnormalized data:")


## plot Barplot of total unnormalized counts
par(mar=c(8,4,4,2))
barplot(colSums(m_counts, na.rm=TRUE),las=2,main ="Total Counts (before normalization) ",border=colors_groups[groups], names.arg=samplenames, cex.names=0.7, cex.main=1, yaxt="n")
axis(side=2, cex.axis=0.7, mgp=c(0,0.7,0), las=2, lwd.ticks=0.5)


## plot Boxplots of unnormalized counts (log2 transformed)
par(mar=c(8,4,4,2))
boxplot(log2(m_counts+1),las=2,main="Boxplots (before normalization)",border=colors_groups[groups],xaxt="n",yaxt="n",ylab="log2 counts", lwd=1.5, cex.main=1)
axis(side=1, at= 1:length(samplenames),las=2, labels=samplenames, cex.axis = 0.75)
axis(side=2)

```

Next, the normalized data (to be used in all subsequent analysis steps) is visualized.

```{r Read in as DESeqDataset and estimate model, echo = FALSE, message = FALSE, warning = FALSE}

## create colData and dds object. Differentiate between design with and without batch effects
if(is.null(batch)){
  colData <- data.frame(data.frame(group = groups))
  rownames(colData) <- samplenames
  dds <- DESeqDataSetFromMatrix(countData = m_counts,
                                colData = colData,
                                design = ~ group)
  } else {
  colData <- data.frame(data.frame(batch=batch, group = groups))
  rownames(colData) <- samplenames
  dds <- DESeqDataSetFromMatrix(countData = m_counts,
                                colData = colData,
                                design = ~ batch + group)
}


## calculate default DESeq model
dds_res <- DESeq(dds)

```


```{r Check DeSeq normalization (size factor normalization), echo = FALSE, message = FALSE, warning = FALSE, fig.align="center"}

## writeLines for html output
writeLines("plotting barplot and boxplots for normalized data:")


## extract normalized counts, add them to df, and do QC
m_counts_norm <- counts(dds_res, normalized=TRUE)
df_m_counts_norm <- as.data.frame(m_counts_norm)
names(df_m_counts_norm) <- paste0("normalized_", names(df_m_counts_norm))
df <- cbind(df, df_m_counts_norm)


## plot Barplot of total unnormalized counts
par(mar=c(8,4,4,2))
barplot(colSums(m_counts_norm, na.rm=TRUE),las=2,main ="Total Counts (normalized) ",border=colors_groups[groups], names.arg=samplenames, cex.names=0.7, cex.main=1, yaxt="n")
axis(side=2, cex.axis=0.7, mgp=c(0,0.7,0), las=2, lwd.ticks=0.5)


## plot Boxplots of unnormalized counts (log2 transformed)
par(mar=c(8,4,4,2))
boxplot(log2(m_counts_norm+1),las=2,main="Boxplots (normalized) ",border=colors_groups[groups],xaxt="n",yaxt="n",ylab="log2 counts", lwd=1.5, cex.main=1)
axis(side=1, at= 1:length(samplenames),las=2, labels=samplenames, cex.axis = 0.75)
axis(side=2)


## define helper function 
my_line <- function(x,y,...){
    range_pairs <- range(log2(m_counts + 1))
    points(x,y,pch=16, col=rgb(red=200, green=200, blue=200, alpha=50, maxColorValue = 255),
           xlim=range_pairs,ylim=range_pairs, cex=1)
    abline(a = 0,b = 1, col="black", lty="dashed")}


## plot pairs plot (max 5vs5)
writeLines("plotting pairwise scatterplots for normalized data:")
if (k > 7){
  ind_rand <- 1:7
  pairs(log2(m_counts_norm + 1)[,ind_rand], panel=my_line, cex.labels=0.9, oma=c(3,3,5,12), main= "Pairs Plot (normalized)", cex.main=1)
} else {
  pairs(log2(m_counts_norm +1), panel=my_line, cex.labels=0.9, oma=c(3,3,5,12), main= "Pairs Plot (normalized)", cex.main=1)
}

```
If normalized properly, we expect most genes to fall around the dashed line. Note: If there are more than 7 samples in the data, this plot just picks the first 7 samples.

<br><br><br><br>  












# General Visualization

<br>  

Note that the data, at this point, is not batch corrected. Potential batch-effects would therefore be visible here. Note that this plot is interactive in the html output! Hover over points to retrieve information.

```{r PCA, echo = FALSE, message = FALSE, warning = FALSE, fig.align="center", fig.width=6, fig.height=4, fig.path='figures/'}

## plot PCA (normalized)
writeLines("plotting PCA:")
PCA_plot(m=log2(m_counts_norm + 1),
         groups = groups,
         legend_colors = colors_groups,
         batch=NULL,
         plot_path = paste0(wd,"/figures/PCA.pdf"))

```


<br>  

```{r Heatmaps, echo = FALSE, message = FALSE, warning = FALSE, fig.align="center", fig.width=6, fig.height=6, fig.path='figures/', dev=c('png', 'pdf')}

## plot heatmap (normalized)
writeLines("plotting global heatmap of normalized log2-transformed counts:")
heatmap_plot(m=log2(m_counts_norm + 1),
             groups = groups,
             legend_colors = colors_groups,
             sample_names = samplenames, 
             type="normal", dendrogram="column" )


## plot heatmap (normalized and centered to each row mean)
writeLines("plotting global heatmap of centered normalized log2 counts (shifted to equal row mean of 0) :")
m_centered <- sweep(log2(m_counts_norm + 1), FUN= "-", STATS = rowMeans(log2(m_counts_norm + 1)), MARGIN=1)
heatmap_plot(m=m_centered,
             groups = groups,
             legend_colors = colors_groups,
             sample_names = samplenames,
             type="centered", dendrogram="column" )


## plot heatmap (normalized and centered to each row mean)
writeLines("plotting global heatmap with standardized log2 counts:")
m_centered <- sweep(log2(m_counts_norm + 1), FUN= "-", STATS = rowMeans(log2(m_counts_norm + 1)), MARGIN=1 )
m_standardized <- sweep(m_centered, FUN="/", STATS=apply(m_centered, FUN=sd, MARGIN = 1), MARGIN = 1)
heatmap_plot(m=m_standardized,
             groups = groups,
             legend_colors = colors_groups,
             sample_names = samplenames,
             type="standardized", dendrogram="column" )


```

Each of these three heatmaps can highlight a different aspect of the data.


<br><br><br><br>    

















# ANOVA

Here, a simple one-way ANOVA tests for overall differences between groups in all gene-wise transcript abundance profiles using log2-transformed gene counts (H0: All groups are equal; H1: At least one group differs from the others). If a batch effect is specified, the ANOVA automatically switches to a 2-way ANOVA by incorporating the batch variable as a covariate into the model. Note that this section is entirely skipped if there are no more than 2 groups overall; or if the minimum number of replicates per group is smaller than 3.

```{r ANOVA, echo = FALSE, message = FALSE, warning = FALSE, fig.align="center"}

if ( length(unique(groups)) > 2  &  min(table(groups)) > 2 ){
  
  # log2, and replace NAs with 0
  m <- log2(m_counts_norm + 1)
  m[is.na(m)] <- min(m, na.rm=TRUE)
  
  # initiate p-val vector
  pval <- numeric(nrow(m))
  
  # go over each gene and conduct ANOVA. Record p-value
  for (i in 1:nrow(m)){
    
    # extract i'th gene abundance pattern
    m_i <- m[i,]
    
    # calculate F-test 
    if (is.null(batch)){
      df_anova_i <- data.frame(Y=m_i,groups=groups)
      model <- aov(data=df_anova_i, formula=Y~groups)
      model_summary <-summary(model)
      pval_i <- model_summary[[1]]$`Pr(>F)`[1]
    } else {
      df_anova_i <- data.frame(Y=m_i,groups=groups, batch=batch)
      model <- aov(data=df_anova_i, formula=Y~groups + batch)
      model_summary <-summary(model)
      pval_i <- model_summary[[1]]$`Pr(>F)`[1]
    }
  pval[i] <- pval_i  
  }
  
  ## save p-value to dataframe
  df$ANOVA_pval <- pval
  
  ## save adj. o-value to dataframe
  df$ANOVA_adj.pval <- p.adjust(pval, method = "BH")
  
  ## plot p-value histogram
  writeLines("plotting ANOVA p-value histogram:")
  hist(df$ANOVA_pval, breaks=20, border="grey", col="grey", xaxt="n", yaxt="n", main="", ylab="", xlab="")
  axis(side=2,cex.axis=0.9)
  axis(side=1, at= seq(0,1,by=0.2), cex.axis=0.9)
  title(main="", cex.main=0.9, cex.lab=0.9, ylab="frequency")
}

```

The bar on the very left reflects p-values < 0.05. Note that per definition, p-values are uniformly distributed if the null hypothesis is true (this applies to any statistical test if the required assumptions for the test are also met - that is why looking at p-value histograms can be quite informative!).


<br><br><br><br>   













# k-Means Clustering: Overview

In this section, k-means clustering is performed on log2-transformed gene-wise transcript abundance profiles. Depending on how the parameter "standardize_before_clustering" is specified, log2-transformed gene-wise counts will further either be centered (if set to FALSE), or standardized (if set to TRUE).

Centered implies that log2 counts of each gene are shifted to reach a mean of 0; i.e. a gene-wise subtraction of the mean log2 count is performed on the normalized, log2-transformed data, in order to pick up common abundance signatures of gene transcripts. Importantly, differences in the y-axis range still represent observed log2 fold change differences this way.

Standardized implies that centered log2 counts will further be normalized based on their variance (thus brought to unit variance). This is identical to what is also referred to as Z-scoring. A drawback of this transformation is that any subsequent clustering will also pick up common noise patterns of non-DE genes (e.g. batch effects, etc.), since variances of non-DE genes will be equally pushed to 1, thereby amplifying "noise". I therefore recommend first filtering for genes that globally differ between groups (in at least 1 group) via ANOVA-derived p-values (this can be specified in the parameter section) when choosing this option. For this analysis, the chosen parameters are:

```{r Print chosen clustering parameters}

print(k_clusters)
print(standardize_before_clustering)
print(ANOVA_filter_before_clustering)

```


```{r Cluster analysis: optimal number of clusters 1, echo = FALSE, message = FALSE, warning = FALSE, fig.align="center"}

## log2, and replace NAs with 0
m <- log2(m_counts_norm + 1)
m[is.na(m)] <- min(m, na.rm=TRUE)
  
 
## before k-means clustering, normalize log-transformed count matrix to achieve equal row means
m_norm <- sweep(m, STATS= rowMeans(m), FUN="-", MARGIN = 1)
m_norm[is.na(m_norm)] <- 0
  

## if specified, also normalize to unit variance (if standardize_before_clustering = TRUE)
if (standardize_before_clustering){
  m_norm_clustering <- sweep(m_norm, FUN="/", STAT=apply(m_norm, MARGIN = 1, FUN=sd), MARGIN=1)
} else {
  m_norm_clustering <- m_norm
}


## if specified, filter out genes that do not pass ANOVA filter
if(ANOVA_filter_before_clustering){
  bool_keep <- df$ANOVA_pval < adj.pval_cutoff
  m_norm_clustering <- m_norm_clustering[bool_keep,]
  writeLines(paste0(nrow(m_norm_clustering)," genes out of ", length(bool_keep), " (", round(mean(bool_keep), digits=3)*100, "%) ", "passed this filter."))
}

```

<br> 

The following plot (sometimes called "elbow-plot") can help to ascertain a reasonable/suitable total number of clusters:

```{r Cluster analysis: optimal number of clusters 2, echo = FALSE, message = FALSE, warning = FALSE, fig.align="center"}

## do k-means clustering with for each k in k_test clusters, and store within Sum of Squares
k_test <- 2:20
N <- nrow(m_norm_clustering)
within_ss <- numeric(length(k_test))
names(within_ss) <- k_test
for (k in k_test){
  KM_k <- kmeans(m_norm_clustering,k ,iter.max = 10, nstart=10)
  within_ss[as.character(k)] <- sum(KM_k$withinss)
}
  
  
# plot SSwithin vs number of clusters
writeLines("empirically testing for optimal number of clusters:")
par(mfrow=c(1,1))
par(mgp=c(2.5,1,0))
plot(y=within_ss,x=k_test,cex.main=0.8, cex.main=0.8,yaxt="n", xaxt="n", pch=16, ylab="", xlab="", type="n")
points(y=within_ss,x=k_test, col="#E69F00", pch=16, cex=1.5)
lines(y=within_ss,x=k_test, lty = 3)
axis(side=2, cex.axis=0.6, mgp=c(0,0.7,0), las=2, lwd.ticks=0.5)
axis(side=1, cex.axis=0.6, mgp=c(0,0.4,0), lwd.ticks=0.5, at=2:20)
title(ylab="residual sum of squares", xlab="number of clusters k")

```

<br> 

For each k-means cluster, the plots below feature:
a) gene-wise transcript abundance profiles as dashed black lines. Further, profiles of genes specified as "genes of special interest" (see parameter section) are highlighted individually in color.
b) the coordinates of the respective k-means cluster center as colored points (colored according to group identity).

```{r Perform k means clustering, echo = FALSE, message = FALSE, warning = FALSE, fig.align="center", fig.path='figures/', dev=c('png', 'pdf')}

## define number of clusters
k = k_clusters


## log2, and replace NAs with 0
m <- log2(m_counts_norm + 1)
m[is.na(m)] <- min(m, na.rm=TRUE)
  
 
## before k-means clustering, normalize datamatrix to achieve equal rowmeans of 0
m_norm <- sweep(m, STATS = rowMeans(m), FUN="-", MARGIN = 1) 
m_norm[is.na(m_norm)] <- 0


## reorder sample order for visual clustering output
if (!is.null(reorder)){
  m_norm <- m_norm[,reorder]
  colors_kmeans <- colors_groups[groups][reorder]
  samplenames_kmeans <- samplenames[reorder]
} else {
  colors_kmeans <- colors_groups[groups]
  samplenames_kmeans <- samplenames
}


## if specified, also normalize to unit variance (if standardize_before_clustering = TRUE)
if (standardize_before_clustering){
  m_norm_clustering <- sweep(m_norm, FUN="/", STAT=apply(m_norm, MARGIN = 1, FUN=sd), MARGIN=1)
} else {
  m_norm_clustering <- m_norm
}


## if specified, filter out genes that do not pass ANOVA filter
if(ANOVA_filter_before_clustering){
  bool_keep <- df$ANOVA_pval < adj.pval_cutoff
  m_norm_clustering <- m_norm_clustering[bool_keep,]
}


## k do k-means clustering with k clusters
KM <- kmeans(m_norm_clustering, k, iter.max = 50, nstart=25)
centers <- KM$centers
table_n <- table(KM$cluster)
par(mgp=c(2.5,1,0))


## add cluster column to the dataframe
if (ANOVA_filter_before_clustering){
  df$kMeans_cluster_center[bool_keep] <- KM$cluster
  df$kMeans_cluster_center[!bool_keep] <- 0
} else {
  df$kMeans_cluster_center <- KM$cluster
}


## extract all protein-coding genes (for enrichment analysis)
bool_proteincoding <- df[,biotype_colname] == proteincoding_entry
proteincoding_genes_total <- df[bool_proteincoding,gene_name]


## initiate plot_list (as plotly can not be plotted inside a loop)
writeLines("plotting individual clusters + gene transcript abundance profiles:")
plot_list <- list()


## check if clustering was performed.
if (!is.null(k)){  
  
  # prepare some variables
  par(mar=c(6.5,4.5,4,5))
  par(mgp=c(3,1,0))
  if(standardize_before_clustering){
    min_y <- quantile(m_norm_clustering, probs=0)
    max_y <- quantile(m_norm_clustering, probs=1)
  } else {
    min_y <- quantile(m_norm_clustering, probs=0.00005)
    max_y <- quantile(m_norm_clustering, probs=0.99995)
  }
  x_axis <- 1:ncol(centers)

  
  # go over each cluster
  for (i in 1:k){
    
    print(i)

    # plot cluster center + individual transcript abundance patterns
    plot(x_axis, centers[i,], xaxt="n", col=colors_kmeans, pch=16, ylab="", xlab="", ylim=c(min_y,max_y), main=paste0("K-Means \n Center of Cluster ",i, " (n=", table_n[i], ")"), cex=1.5, type="n", yaxt="n", cex.main=0.9, cex.lab=2)
    axis(side=1, labels=samplenames_kmeans, at=x_axis, cex.axis=0.65, las=2)
    axis(side=2, cex.axis=0.8)
    if(standardize_before_clustering){
      ylab <- "standardized log2 counts"
    } else {
      ylab <- "centered log2 counts"
    }
    title(ylab=ylab, cex.lab=0.9)
    bool_i <- KM$cluster == i
    m_norm_i <- m_norm_clustering[bool_i,, drop=FALSE]
    if (nrow(m_norm_i)==1) next
    
    # plot lines of all proteins
    for(j in sample(1:nrow(m_norm_i))){
      lines(x_axis, m_norm_i[j,], xaxt="n", xlab="", ylim=c(min_y,max_y), lty=1, col="black", lwd=0.05)
    }
  
    # plot lines of genes of interest extra if specified
    if(!is.null(genes_of_special_interest) && any(rownames(m_norm_i) %in% gene_id_genesOfInterest)){
      ind_interest_i <- which(rownames(m_norm_i) %in% gene_id_genesOfInterest)
      m_norm_i_interest <- m_norm_i[ind_interest_i,,drop=FALSE]
      gene_id_genesOfInterest_i <- rownames(m_norm_i_interest)
      gene_names_genesOfInterest_i <- df$gene_name[df$gene_id %in% gene_id_genesOfInterest_i]
      for (j in 1:nrow(m_norm_i_interest)){
        lines(x_axis, m_norm_i_interest[j,], xaxt="n", xlab="n", ylim=c(min_y,max_y), lty=2, lwd=2, col=col_genes[gene_id_genesOfInterest_i[j]])
      }
      par(xpd=TRUE)
      legend("right", legend=gene_names_genesOfInterest_i, col=col_genes[gene_id_genesOfInterest_i], lty=2, lwd=2, bty="n", inset=-0.20, cex=0.7)
      par(xpd=FALSE)
    }
    
    # plot cluster centers
    points(x_axis, centers[i,] , xaxt="n", col=colors_kmeans, pch=16, ylab="reporter intensity", xlab="", 
           ylim=c(min_y,max_y), main=paste0("K-Means \n Center of Cluster ",i, " (n=", table_n[i], ")"), cex=1.3)
    
    # create heatmap of cluster i
    par(xpd=TRUE)
    pdf(file = paste0(wd,"/figures/","Cluster_",i,"_heatmap.pdf"))
    heatmap_plot(m=m_norm_i,
             groups = groups,
             legend_colors = colors_groups,
             sample_names = samplenames,
             type="standardized", dendrogram="column" )
    dev.off()
    
    # save m_norm_i via write.table()
    write.table(m_norm_i, file=paste0(wd, "/clusters/","Table_Cluster_",i,".txt"), row.names = TRUE, col.names = NA, quote=FALSE, sep = "\t" )
    dim(m_norm_i)
    
    
    # perform enrichment analysis using gprofiler2 (fisher-exact testing)
    proteincoding_genes_i <- df$gene_name[df$kMeans_cluster_center==i & df[,biotype_colname] == proteincoding_entry]
    if (enrichment_analysis & length(proteincoding_genes_i) < length(proteincoding_genes_total)/3 & length(proteincoding_genes_i) > 0){
    
      # run gost function (on protein coding genes only)
      query_list_i <- list(proteincoding_genes_i)
      names(query_list_i) <- paste0("Cluster_",i)
      if(custom_background){
        background_list <- proteincoding_genes_total
        res_gost <- gost(query = query_list_i, 
                         organism = organism, ordered_query = FALSE, 
                         multi_query = FALSE, significant = TRUE, exclude_iea = TRUE, 
                         measure_underrepresentation = FALSE, evcodes = TRUE, 
                         user_threshold = pval_threshold_enrichment, correction_method = "fdr", 
                         custom_bg = background_list, domain_scope = "custom", 
                         numeric_ns = "", sources = sources_enrichment, as_short_link = FALSE)
      } else {
        print(i)
        res_gost <- gost(query = query_list_i, 
                         organism = organism, ordered_query = FALSE, 
                         multi_query = FALSE, significant = TRUE, exclude_iea = TRUE, 
                         measure_underrepresentation = FALSE, evcodes = TRUE, 
                         user_threshold = pval_threshold_enrichment, correction_method = "fdr", 
                         custom_bg = NULL, domain_scope = "annotated", 
                         numeric_ns = "", sources = sources_enrichment, as_short_link = FALSE)
        print(i)
      }

      # store enrichment results as text files
      wd <- getwd()
      enrichment_filepath <- paste0(wd, "/enrichment")
      if(!is.null(res_gost)){
        enrichment_res_i <- res_gost$result
        enrichment_res_i <- enrichment_res_i[!sapply(enrichment_res_i, FUN=is.list)]
        enrichment_res_i$enrichment_factor <- (enrichment_res_i$intersection_size/enrichment_res_i$query_size)/(enrichment_res_i$term_size/enrichment_res_i$effective_domain_size)
        enrichment_res_i <- enrichment_res_i[,c("term_name", "p_value", "enrichment_factor", "effective_domain_size", "term_size", "query_size", "intersection_size", "term_id", "source", "intersection")]
        write.table(enrichment_res_i, file=paste0(enrichment_filepath,"/EnrichmentResults_cluster",i,".txt"), row.names = FALSE, col.names = TRUE, quote=FALSE, sep = "\t")
      }

      # save enrichment results of cluster i as plot 
      if (!is.null(res_gost)){
        res_gost$result <- res_gost$result %>% filter(intersection_size > 1) %>% filter(term_size <5000)
        if(nrow(res_gost$result) == 0){next}
        p <- gostplot(res_gost, interactive = TRUE, capped=FALSE)
        plot_list <- list.append(plot_list, ggplotly(p))
      }
    }
  }
    
  # create filepath to save gene lists of clusters 
  wd <- getwd()
  cluster_filepath <- paste0(wd, "/clusters")
    
  # create txt-file with all gene names (serves as reference)
  write.table(df$gene_name, file=paste0(cluster_filepath, "/Gene_names_all.txt"), row.names = FALSE, col.names = FALSE, quote=FALSE)
    
  # create txt-file with gene names for each of the k clusters
  for (i in 1:k){
    filepath_k <- paste0(cluster_filepath, "/Gene_names_cluster_", i, ".txt")
    write.table(df$gene_name[df$kMeans_cluster_center == i], file=filepath_k, row.names = FALSE, col.names = FALSE, quote=FALSE)
  }
}


## finally, plot number of genes in each cluster
writeLines("plotting number of genes per cluster:")
barplot(table_n, xlab = "cluster ID", ylab="# of genes", border="grey", col="grey")


```


<br><br><br>   










# k-Means Clustering: Enrichment Analysis 

In this section, using g:Profiler, gene set functional enrichment analysis via ORA (overrepresentation analysis) is performed on the protein-coding genes of each cluster. If the parameter custom_background is set to TRUE, all quantified protein-coding genes within the experiment are defined as a custom background list (more specifically, all protein-coding genes that passed the initial filtering step based on minimum total read counts). Else, if this parameter is set to FALSE, the enrichment analysis takes the entire annotated genome of the specified organism as a background. g:Profiler then tests for overrepresentation of specific annotated gene sets via Fisher's Exact Test. These gene sets come from several public databases like GO (Gene Ontology), KEGG (Kyoto Encyclopedia of Genes and Genomes), REAC (Reactome), WP (WikiPathways), HP (Human phenotype ontology), CORUM (CORUM, database of mammalian protein complexes).

The enrichment analysis returns no visual plot output for a cluster when it contains more than 1/3 of the total number of quantified protein-coding genes in the experiment (this setting is intentional in order to limit processing time - the bigger the query list, the more time the calculation takes; but also because the interpretation of an "enrichment" is rather unclear in such a case anyway in my opinion), or when a cluster's gene list does not produce any statistically significant hits. Moreover, enrichment terms with a term size over 5000 are not displayed (as they are often too generic to be useful), and neither are enrichment terms that produce an intersection set consisting of only a single gene. 

The visual output is reminiscent of Manhatten-plots (which is created by an in-build function of the g:Profiler software): The x-axis corresponds to functional terms which are grouped and color-coded according to the different database sources they originate from. The y-axis displays the significance of gene sets tested for enrichment. Each point thus corresponds to a single gene set that was found enriched in the respective cluster, i.e. surpassing a statistical significance threshold as defined in the parameter section. The point size corresponds to the number of genes in the respective gene set. 

Note that the individual enrichment testing results are also documented in a separate folder called "enrichment"! Additionally, the file "EnrichmentAnalysis_Userguide.pdf" explains how the data can be interpreted/understood.

The parameters for this analysis were chosen as:

```{r print chosen enrichment testing parameters 1}

print(enrichment_analysis)
print(custom_background)
print(organism)
print(pval_threshold_enrichment)
print(sources_enrichment)

```


```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.align="center", fig.height=8, fig.width=4}

## plot the plots outside a loop
par(mar=c(1,1,1,1))
htmltools::tagList(setNames(plot_list, NULL))

```

The localization of terms on the x-axis is not random: Similar, hierarchically connected terms are in close proximity to each other. 
Also, detailed information on all statistically enriched gene sets is saved separately as tables in the "enrichment" folder. This also includes lists of individual gene names that caused a specific term to appear enriched (see column named: "intersection") in the respective cluster (i.e. the query gene list). This table is very useful, as it allows filtering for term size (smaller term size -> less generic, i.e. more specific biological pathway/processn information). Finally, heatmaps of transcript abundance profiles for all genes within each cluster are saved separately in the folder named "figures".

<br><br><br><br>   












# Pairwise DE Testing: Overview

Pairwise differential expression (DE) testing is performed using the R package DESeq2. This package models RNA read counts as negative binomially distributed count data within a generalized linear model setting. Batch effects will be included as fixed effects into the model (i.e. as separate regressor variables). This section returns p-value histograms of pairwise group comparisons, as well as corresponding volcano plots that highlight genes of special interest (as specified in the parameter section). Note that for the volcano plots, fold change shrinkage for low-abundance genes has been performed.

```{r DE testing, echo = FALSE, message = FALSE, warning = FALSE, fig.align="center", fig.path='figures/', dev=c('png', 'pdf')}

## go over each specified pairwise comparison
if (!is.null(pairwise_comp)){
  
  # print experimental design
  writeLines("Experimental design:")
  colData
  
  # initiate plot_list
  plot_list <- list()
  
  # go over each specified pairwise comparison to be conducted
  for (i in 1:length(pairwise_comp)){
    
    # extract current pairwise comparison, and print it
    comp_i <- pairwise_comp[[i]]
    writeLines("Conducting the following pairwise group comparison")
    print(comp_i)
    
    # pairwise comparison by specification of contrast
    coef_i <- paste0("group_", comp_i[1], "_vs_", comp_i[2])
    dds_res_i <- DESeq(dds)
    dds_res_i <- results(dds_res, contrast = c("group", comp_i[1],  comp_i[2]), alpha = 0.05)
    
    # print summary
    writeLines("Results:")
    summary(dds_res_i)
    
    # calculate and plot p-value histograms
    cat("\n")
    writeLines("\nHistogram of p-values and adjusted p-values:")
    ymax = sort(table(cut(dds_res_i$pvalue, breaks=seq(from=0,to=1,length.out = 26))), decreasing = TRUE)[1]
    par(mfrow=c(2,1))
    par(mgp=c(1.6, 0.7, 0))
    par(mar=c(1,4,3,9))
    hist(dds_res_i$pvalue, breaks=20, border="#999999", col="#999999", xaxt="n", yaxt="n", ylim=c(0,ymax), xlim=c(0,1), main="", ylab="", xlab="")
    axis(side=2,cex.axis=0.6)
    axis(side=1, at= seq(0,1,by=0.2), cex.axis=0.6)
    title(main=paste0("Distribution of p-values\n",comp_i[2], " vs ", comp_i[1]), cex.main=0.7, cex.lab=0.7, ylab="frequency \n (p-values) ")
    par(mar=c(3,4,1,9))
    hist(dds_res_i$padj, breaks=20, border="#E69F00", col="#E69F00", xaxt="n", yaxt="n", ylim=c(0,ymax), xlim=c(0,1), main="", ylab="", xlab="")
    axis(side=2,cex.axis=0.6)
    axis(side=1, at= seq(0,1,by=0.2), cex.axis=0.6)
    title(main="", cex.main=0.7, cex.lab=0.7, ylab="frequency \n (adjusted p-values) ")
    
    # calculate FC shrinkage and plot volcano plots
    dds_res_shrink_i <- lfcShrink(dds_res, contrast = c("group", comp_i[1],  comp_i[2]), type = "ashr")
    
    # calculate volcano plot and MA plot variables
    fc_i <- dds_res_shrink_i$log2FoldChange
    neg_log_pval <- -log10(dds_res_shrink_i$pvalue)
    adj_pval <- dds_res_shrink_i$padj
    neg_log_adj_pval <- -log10(adj_pval)
    x_extreme <- max(abs(range(fc_i)))
    
    ## make a p-value cap at 10^(-50)
    neg_log_adj_pval[is.infinite(neg_log_adj_pval)] <- 50
    neg_log_adj_pval[neg_log_adj_pval>50] <- 50
    
    # plot volcano plots (highlighting genes of interest)
    writeLines("Volcano plot highlighting genes of special interest:")
    par(xpd=TRUE)
    par(mfrow=c(1,1))
    par(mar=c(5,4,4,9))
    par(mgp=c(2.5, 0.7, 0))
    par(font.axis=1)
    ind_interest <- df$gene_name %in% genes_of_special_interest
    plot(x = fc_i, y = neg_log_adj_pval,
           pch=16, cex=0.9, xaxt="n", yaxt="n", xlab= paste0(comp_i[1], " / ", comp_i[2], " \nfold change [log2]" ), ylab = "- log10 (p-value)",main= "Volcano Plot", 
           cex.lab=0.7, cex.main= 0.8, font.lab=2, col="grey", xlim=c(-x_extreme,x_extreme), bty="L", type="n")
    axis(side=1, cex.axis=0.7)
    axis(side=2, cex.axis=0.7, las=2, mgp=c(2.5, 0.8, 0))
    points(x=fc_i, y=neg_log_adj_pval, pch=16, cex=0.9, xaxt="n", col=rgb(red=200, green=200, blue=200, alpha=100, maxColorValue = 255))
    points(x=fc_i[ind_interest], y=neg_log_adj_pval[ind_interest], pch=16, cex=1.5, xaxt="n", col=df$col_genes[ind_interest])
    legend("right", legend=df$gene_name[ind_interest], pch=16, bty="n", col=df$col_genes[ind_interest], cex=0.7, inset=c(-0.2,0))
    
    # prepare volcano plot as ggplot and save it in list
    df_gg <- data.frame(fc = dds_res_shrink_i$log2FoldChange,
                        neg_log_adj_pval = -log10(dds_res_shrink_i$padj))
    df_gg$neg_log_adj_pval[is.na(df_gg$neg_log_adj_pval)] <- 0
    df_gg$neg_log_adj_pval[is.infinite(df_gg$neg_log_adj_pval)] <- 50
    df_gg$neg_log_adj_pval[df_gg$neg_log_adj_pval>50] <- 50
    df_gg$significance <- cut(df_gg$neg_log_adj_pval, breaks=c(Inf, -log10(0.001), -log10(0.01), -log10(0.05), 0), right=FALSE)
    levels(df_gg$significance) <- c("non-significant", "adj. pval < 0.05", "adj. pval < 0.01", "adj. pval < 0.001")
    df_gg$gene_name <- df$gene_name
    gg <- ggplot(data=df_gg) +
              geom_point(aes(x=fc, y=neg_log_adj_pval, col=significance, text=gene_name), alpha=0.5, cex=2) +
              scale_color_manual(values=c(rgb(red=200, green=200, blue=200, alpha=100, maxColorValue = 255),
                                  rgb(red=250, green=200, blue=0, alpha=100, maxColorValue = 255),
                                  rgb(red=245, green=130, blue=0, alpha=100, maxColorValue = 255),
                                  rgb(red=255, green=50, blue=50, alpha=100, maxColorValue = 255)))+
              xlim(-x_extreme, x_extreme) +
              ggtitle(paste0("Volcano plot ", comp_i[1], " / ", comp_i[2])) +
              ylab(" - log10 adj. p-val") + xlab(paste0(comp_i[1], " / ", comp_i[2], " \nfold change [log2]" )) +
              theme_bw()
    plot_list <- list.append(plot_list, ggplotly(gg))
                  
    # save volcano plot separately
    ggsave(plot=gg, filename=paste0(wd,"/figures/Volcano_",comp_i[1], "_vs_", comp_i[2],".pdf"))
          
    # extract all protein-coding genes (for enrichment analysis)
    bool_proteincoding <- df[,biotype_colname] == proteincoding_entry
    proteincoding_genes_total <- df[bool_proteincoding,gene_name]
    
    # construct and plot heatmap of significant genes (adj. p-value < 0.05), including top 20 up and downregulated genes
    if (any(adj_pval < 0.05)){
      m_counts_norm_named <- m_counts_norm
      rownames(m_counts_norm_named) <- df[,gene_name]
      bool_significant <- adj_pval < 0.05
      bool_significant[is.na(bool_significant)] <- FALSE
      df_significant <- data.frame(adj_pval = adj_pval[bool_significant],
                                  fc = fc_i[bool_significant],
                                  gene_name = df[,gene_name][bool_significant])
      m_significant <- m_counts_norm_named[bool_significant,]
      m_significant <- log2(m_significant + 1)
      m_significant <- m_significant[,groups %in% c(comp_i[1], comp_i[2])]
      m_significant_centered <- sweep(m_significant, STATS = rowMeans(m_significant), FUN="-", MARGIN = 1)

      
      # top upregulated genes
      if (any(df_significant$fc > 0)){
        writeLines("plotting heatmap of top upregulated genes (log2-transformed centered normalized counts)")
        df_upregulated <- df_significant[df_significant$fc>0,]
        df_upregulated <- df_upregulated[order(df_upregulated$adj_pval),]
        gene_names_upreg <- df_upregulated$gene_name[1:pmin(20, nrow(df_upregulated))]
        heatmap_plot(m_significant_centered[gene_names_upreg,],
                     groups = groups[groups %in% c(comp_i[1], comp_i[2])],
                     legend_colors = NULL,
                     sample_names = samplenames[groups %in% c(comp_i[1], comp_i[2])],
                     type="centered",
                     labrow= rownames(m_significant_centered[gene_names_upreg,]),
                     bool_rowv=FALSE, 
                     bool_colv = FALSE)
      }
      # top downregulated genes
      if (any(df_significant$fc < 0)){
        writeLines("plotting heatmap of top downregulated genes (log2-transformed centered normalized counts)")
        df_downregulated <- df_significant[df_significant$f<0,]
        df_downregulated <- df_downregulated[order(df_downregulated$adj_pval),]
        gene_names_downreg <- df_downregulated$gene_name[1:pmin(20, nrow(df_downregulated))]
        heatmap_plot(m = m_significant_centered[gene_names_downreg,],
                     groups = groups[groups %in% c(comp_i[1], comp_i[2])],
                     legend_colors = NULL,
                     sample_names = samplenames[groups %in% c(comp_i[1], comp_i[2])],
                     type="centered",
                     labrow= rownames(m_significant_centered[gene_names_downreg,]),
                     bool_rowv=FALSE, 
                     bool_colv = FALSE)
      }    
    }

  
    # add DE testing results to df (shrinked FC)
    names_res <- names(dds_res_shrink_i)
    newnames_res <- paste0(names_res, "__", coef_i)
    names(dds_res_shrink_i) <- newnames_res
    df <- cbind(df, dds_res_shrink_i)
  }
}

```
<br><br><br>   










# Pairwise DE Testing: Interactive Volcano Plots 

In this section, the same volcano plots from above are plotted again but as interactive plots in the html output (hover over points to retrieve gene name information!) while also indicating the significant level of each gene. Adjusted p-values are capped at 10^(-50).

```{r print ggplotly volcano plots, echo = FALSE, message = FALSE, warning = FALSE, fig.align="center", fig.height=8, fig.width=4}

## plot the plots outside a loop
if (!is.null(pairwise_comp)){
  par(mar=c(1,1,1,1))
  htmltools::tagList(setNames(plot_list, NULL))
}
```
<br><br><br>   












# Export Analysis

Here, the filtered and normalized data is exported, now also containing the DE testing results as additional columns + k-means cluster information.
```{r Export table, echo = FALSE, message = FALSE, warning = FALSE}

## export as tab separated text file
if (export_matrix){
  write.table(df, file = paste0("Matrix_Export_", Sys.Date(), ".txt"), sep = "\t", col.names = TRUE, row.names=FALSE, quote=FALSE)
  # print info about export matrix:
  writeLines("Generated output txt-file file called:")
  writeLines(paste0("Matrix_Export_", Sys.Date(), ".txt"))
  writeLines(paste0("(",dim(df)[1], " rows, ", dim(df)[2], " columns)" ))
}  
  
```


<br><br><br><br><br> 



```{r}

```














